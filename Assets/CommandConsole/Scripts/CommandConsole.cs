using System;
using System.Reflection;
using UnityEngine;
using System.IO;
using System.Collections.Generic;
using UnityEngine.UI;
using UnityEngine.EventSystems;
using System.Threading;
using System.Linq;
using System.Globalization;
using System.CodeDom.Compiler;

namespace CharlesOlinerCommandConsole {
    public class CommandConsole : MonoBehaviour {

        /* COMMAND CONSOLE
         * This system allows a user to enter raw C# code into their game at runtime and have it executed.
         */
        [HideInInspector] public ConsoleOpenListener listener;

        static Type[] autocompleteBestTypes = new Type[] {
            //feel free to add types to this list. their members will show up in autocomplete even when fullAutocompleteLibrary isn't checked.
            typeof(Debug),
            typeof(Application),
            typeof(GameObject),
            typeof(MonoBehaviour),
            typeof(ConsoleCommand),
            typeof(Camera),
            typeof(Light),
            typeof(Physics), typeof(RaycastHit), typeof(Rigidbody),
            typeof(Physics2D), typeof(RaycastHit2D), typeof(Rigidbody2D),
            typeof(Transform), typeof(RectTransform),
            typeof(Vector2),  typeof(Vector3), typeof(Vector4), typeof(Quaternion), typeof(Matrix4x4),
            typeof(Shader), typeof(Material),
            typeof(RenderTexture), typeof(Texture2D), typeof(Texture3D),
            typeof(Mesh), typeof(MeshRenderer), typeof(SkinnedMeshRenderer), typeof(MeshFilter),
            typeof(Math), typeof(Mathf), typeof(UnityEngine.Random),
            typeof(Text),
            typeof(object)
        };
        const int maxNumAutocompleteSuggestions = 256; //256 is devinately more than enough
        string[] autocompleteWordsArray = null;
        string[] autocompleteSuggestions = new string[maxNumAutocompleteSuggestions];
        [HideInInspector] public RectTransform autocompleteButtonPanel;
        Text[] autocompleteButtonTexts = new Text[maxNumAutocompleteSuggestions];
        [HideInInspector] public Toggle autoCompleteToggle;
        [HideInInspector] public Toggle languageToggle;

        [HideInInspector] public InputField inputField;
        [HideInInspector] public Text inputFieldExpansionText;

        [HideInInspector] public InputField outputField;
        [HideInInspector] public Text outputFieldExpansionText;
        string outputFieldText = "Console created by Charles Oliner.";
        string outputFieldRichText = "Console created by Charles Oliner.";

        [HideInInspector] public Text selectedObjectText;

        [HideInInspector] public Text toolTipExpansionText; //"expansion texts" are used to make a panel containing text fit the size of the text.
        [HideInInspector] public Text toolTipText;
        [HideInInspector] public Image toolTipPanel;

        [HideInInspector] public Text autocompletePrepText;

        [HideInInspector] public Toggle showEnclosingCodeToggle;
        [HideInInspector] public Toggle enterCompilesToggle;
        [HideInInspector] public Toggle showStackTracesToggle;
        [HideInInspector] public Button abortButton;

        [HideInInspector] public Slider[] colorSliders; //RGBHSVA
        [HideInInspector] public InputField[] colorFields; //RGBHSVA
        [HideInInspector] public InputField colorOutput;

        RectTransform top; //rect of most northerly element in console
        RectTransform bottom; //rect of most southerly element in console
        RectTransform console; //the entire Console's rect.

        List<string> commandHistory = new List<string>(); //list of previous commands to be revisited by the user
        int historyIndex = 0; //how far back you currently are

        ulong numGenerated = 0; //number of assemblies generated by the compiler. increments even when compilation fails.

        List<Hotkey> hotkeys = new List<Hotkey>(); //does not include things like compile and run, console scroll- jsut the hotkeys that auto-type stuff.
        [HideInInspector] public RectTransform hotkeyButtonPanel; //panel to put the hotkey buttons in
        [HideInInspector] public GameObject hotkeyButtonPrefab; //prefab for a UI button that can be pressed instead of using a hotkey. this prefab is also used as autocomplete buttons.

        [HideInInspector] public Sprite buttonSprite;
        [HideInInspector] public Sprite buttonPressedSprite;
        [HideInInspector] public Sprite buttonDisabledSprite;

        [HideInInspector] public List<Button> supressDuringCompilationButtons = new List<Button>(); //buttons to supress during compilation. other (non-button) things are also supressed during compilation

        string standardOutput; //used to collect ouput from csc.exe
        Thread compilationWaiter; //waits for compiler to finish

        List<uint> syntaxErrorsLines = new List<uint>(); //line and column ints (32 bits) back to back as 64-bit ulongs

        int caret; //because we can't trust InputField to keep track of its caret.
        bool inputFieldSelected;

        Thread generateAutocompleteDictionaryThread;
        string title = ""; //these strings are used for indicating the progress of the dictionary generation.
        string info = "";

        public static CommandConsole main;

        public class ReferenceLoader : MarshalByRefObject {
            public Assembly LoadReferences(string assemblyPath) {
                var assembly = Assembly.ReflectionOnlyLoadFrom(assemblyPath);
                return assembly;
            }
        }

        void Start() {

            Application.logMessageReceived += ProcessLog;

            main = this;

            AddHotkey(KeyCode.D, "Destroy", "Destroy(so);", -2, "Destroys an object from the scene at the end of the frame.");
            AddHotkey(KeyCode.E, "Members", "members(typeof());", -3, "Lists all accessible members of a type, including functions, variables, and nested classes.");
            AddHotkey(KeyCode.I, "Find", "so = GameObject.Find(\"\");", -3, "Finds a GameObject from the scene by name.");
            AddHotkey(KeyCode.L, "Log", "Debug.Log(\"\");", -3, "Logs a message to the Unity console (and to this console).");
            AddHotkey(KeyCode.M, "Message", "so.SendMessage(\"\");", -3, "Calls the method with the given name on every MonoBehaviour attatched to the target GameObject.");
            AddHotkey(KeyCode.R, "Relocate", "relocate(so);", -2, "Moves an object to wherever your mouse is pointing and cancels its velocity, if any.");
            AddHotkey(KeyCode.S, "Summon", "so = summon(\"\");", -3, "Instantiates the prefab in the Resources folder with the given name wherever the mouse is pointing.");
            AddHotkey(KeyCode.U, "Push", "push(so);", -2, "Adds a 3D Physics force to an object.");

            //instantiate autocomplete buttons (or destroy autocomplete-related objects, if allowAutocomplete is false)
            if (listener.allowAutocomplete) {
                for (int i = 0; i < maxNumAutocompleteSuggestions; i++) {
                    GameObject g = Instantiate(hotkeyButtonPrefab);
                    g.transform.SetParent(autocompleteButtonPanel);
                    g.name = "Autocomplete Button " + i;
                    g.SetActive(false);

                    Text t = g.transform.GetChild(0).GetComponent<Text>();
                    t.text = "";
                    autocompleteButtonTexts[i] = t;

                    int j = i;
                    Button b = g.GetComponent<Button>();
                    b.onClick.AddListener((() => { int k = j; Autocomplete(k); }));

                    if (i == 0) {
                        EventTrigger trigger = g.AddComponent<EventTrigger>();

                        EventTrigger.Entry entry = new EventTrigger.Entry();
                        entry.eventID = EventTriggerType.PointerEnter;
                        entry.callback.AddListener((eventData) => { toolTipText.text = "(Alt)"; });
                        trigger.triggers.Add(entry);

                        entry = new EventTrigger.Entry();
                        entry.eventID = EventTriggerType.PointerExit;
                        entry.callback.AddListener((eventData) => { toolTipText.text = ""; });
                        trigger.triggers.Add(entry);
                    }
                }
            } else {
                autoCompleteToggle.interactable = false;
                autoCompleteToggle.GetComponent<Image>().sprite = buttonDisabledSprite;
                Destroy(autocompleteButtonPanel.gameObject);
                Destroy(autocompletePrepText.transform.parent.gameObject);
            }

            //add triggers to autocomplete toggle
            EventTrigger.Entry e = new EventTrigger.Entry();
            e.eventID = EventTriggerType.PointerEnter;
            if (autoCompleteToggle.interactable)
                e.callback.AddListener((eventData) => { toolTipText.text = "Autocomplete"; });
            else
                e.callback.AddListener((eventData) => { toolTipText.text = "Autocomplete (disabled in Editor)"; });
            autoCompleteToggle.GetComponent<EventTrigger>().triggers.Add(e);

            commandHistory.Add(inputField.text);

            top = outputField.GetComponent<RectTransform>();
            bottom = inputField.GetComponent<RectTransform>();
            console = GetComponent<RectTransform>();

            //clear dlls from last session
            DirectoryInfo di = new DirectoryInfo(Directory.GetCurrentDirectory());
            foreach (FileInfo file in di.GetFiles()) {
                if (file.Name.StartsWith("commandLibrary")) {
                    switch (file.Extension) {
                        case ".dll":
                            file.Delete();
                            break;
                        case ".mdb":
                            file.Delete();
                            break;
                    }
                }
            }
        }

        public void pasteHexColor() {
            string c = GUIUtility.systemCopyBuffer;
            c = c.Replace("#", "");
            c = c.Replace("0x", "");
            c = c.Replace("&H", "");
            c = c.Trim();
            if (c.Length < 6) {
                Debug.LogWarning("Invalid hex (too short): " + c);
                return;
            }

            int r, g, b, a = 255;

            if (!int.TryParse(c.Substring(0, 2), NumberStyles.HexNumber, null, out r)) {
                Debug.LogWarning("Invalid hex (R-value parsing failed): " + c);
                return;
            }
            if (!int.TryParse(c.Substring(2, 2), NumberStyles.HexNumber, null, out g)) {
                Debug.LogWarning("Invalid hex (G-value parsing failed): " + c);
                return;
            }
            if (!int.TryParse(c.Substring(4, 2), NumberStyles.HexNumber, null, out b)) {
                Debug.LogWarning("Invalid hex (B-value parsing failed): " + c);
                return;
            }

            if (c.Length >= 8)
                int.TryParse(c.Substring(6, 2), NumberStyles.HexNumber, null, out a);

            withinSliderChange = true;
            colorSliders[0].value = r / 255f;
            colorSliders[1].value = g / 255f;
            colorSliders[2].value = b / 255f;
            colorSliders[6].value = a / 255f;
            withinSliderChange = false;
            colorField(colorSliders[0]);
            Debug.Log("Hex pasted.");
        }

        int currentlyChangingText = -1;
        public void colorText(InputField field) {
            if (withinSliderChange)
                return;
            int index = Array.IndexOf(colorFields, field);
            float value;
            if (float.TryParse(field.text, out value)) {
                currentlyChangingText = index;
                colorSliders[index].value = value;
                currentlyChangingText = -1;
            }
        }

        bool withinSliderChange;
        public void colorField(Slider slider) {
            if (withinSliderChange)
                return;
            withinSliderChange = true;
            Color c;
            int index = Array.IndexOf(colorSliders, slider);
            if (index < 3) {
                c.r = colorSliders[0].value;
                c.g = colorSliders[1].value;
                c.b = colorSliders[2].value;
                c.a = colorSliders[6].value;

                float hue, sat, lum;
                Color.RGBToHSV(c, out hue, out sat, out lum);

                colorSliders[3].value = hue;
                colorSliders[4].value = sat;
                colorSliders[5].value = lum;
            } else if (index < 6) {
                c = Color.HSVToRGB(colorSliders[3].value, colorSliders[4].value, colorSliders[5].value);
                c.a = colorSliders[6].value;

                colorSliders[0].value = c.r;
                colorSliders[1].value = c.g;
                colorSliders[2].value = c.b;
            } else {
                c.r = colorSliders[0].value;
                c.g = colorSliders[1].value;
                c.b = colorSliders[2].value;
                c.a = colorSliders[6].value;
            }

            for (int i = 0; i < 7; i++) {
                if (i == currentlyChangingText)
                    continue;
                string a = colorSliders[i].value + "";
                if (a.Length > 5)
                    colorFields[i].text = a.Substring(0, 5);
                else
                    colorFields[i].text = a;
            }

            float displayLum = colorSliders[5].value * colorSliders[6].value + (1 - colorSliders[6].value);
            colorOutput.textComponent.color = (displayLum > 0.5f) ? Color.black : Color.white;

            colorOutput.image.color = c;
            colorOutput.text = string.Format("hex #{0:x2}{1:x2}{2:x2}{3:x2}",
                                    Mathf.RoundToInt(colorSliders[0].value * 255),
                                    Mathf.RoundToInt(colorSliders[1].value * 255),
                                    Mathf.RoundToInt(colorSliders[2].value * 255),
                                    Mathf.RoundToInt(colorSliders[6].value * 255)) + '\n' +
                               string.Format("new Color({0}f,{1}f,{2}f,{3}f);", colorFields[0].text, colorFields[1].text, colorFields[2].text, colorFields[6].text);
            withinSliderChange = false;
        }

        /// <summary>
        /// Adds an auto-type hotkey combo and a hotkey button to the auto-type hotkeys system.
        /// </summary>
        /// <param name="key">The final key in the key combo, after Control and Shift.</param>
        /// <param name="name">The short name of the auto-typed code that appears on the button.</param>
        /// <param name="code">The code to be typed automatically when the key combo is used or the button is pressed.</param>
        /// <param name="cursorOffset">The offset from the end of the auto-typed code that the cursor should be placed at. Should be negative if you want the cursor to be within the auto-typed code, or zero if you want it at the end.</param>
        /// <param name="desc">A description of what the code does.</param>
        /// <example> 
        /// This sample shows how to call the <see cref="AddHotkey"/> method.
        ///     <code>
        ///         AddHotkey(KeyCode.C, "Cosine", "Mathf.Cos();", -2, "Returns the cosine of the provided angle (in radians).");
        ///     </code>
        /// </example>
        public void AddHotkey(KeyCode key, string name, string code, int cursorOffset, string desc) {
            int index = hotkeys.Count;

            hotkeys.Add(new Hotkey(key, name, code, cursorOffset, desc));

            GameObject g = Instantiate(hotkeyButtonPrefab);
            g.transform.SetParent(hotkeyButtonPanel);
            g.name = name + " Button";
            Text t = g.transform.GetChild(0).GetComponent<Text>();
            t.text = name + " <color=grey>(Ctrl+Alt+" + key + ")</color>";

            EventTrigger trigger = g.GetComponent<EventTrigger>();

            EventTrigger.Entry entry = new EventTrigger.Entry();
            entry.eventID = EventTriggerType.PointerEnter;
            entry.callback.AddListener((eventData) => { string f = desc + " <color=grey>" + code + "</color>"; toolTipText.text = f; });
            trigger.triggers.Add(entry);

            entry = new EventTrigger.Entry();
            entry.eventID = EventTriggerType.PointerExit;
            entry.callback.AddListener((eventData) => { toolTipText.text = ""; });
            trigger.triggers.Add(entry);

            int j = index;
            Button b = g.GetComponent<Button>();
            b.onClick.AddListener((() => { int i = j; HotkeyExecute(i); }));

            supressDuringCompilationButtons.Add(b);
        }

        struct Hotkey {
            public KeyCode key;
            public string name;
            public string code;
            public string description;
            public int cursorOffset;

            public Hotkey(KeyCode key, string name, string code, int cursorOffsetFromEnd, string description) {
                this.key = key;
                this.name = name;
                this.code = code;
                this.description = description;
                cursorOffset = code.Length + cursorOffsetFromEnd;
            }
        }

        public void CursorPositionResetHelper(bool selected) { //because we can't trust InputField to keep track of its caret when we deselect it.
            if (!selected)
                inputField.caretPosition = caret;
            inputFieldSelected = selected;
        }

        public void AbortCompilation() {
            if (compilationWaiter != null) {
                string effectiveCsOutputPath = "commandScript" + numGenerated.ToString("00000000000000000000") + ".cs";
                File.Delete(effectiveCsOutputPath);
                compilationWaiter.Abort();
                compilationWaiter = null;
                ProcessCommandEnd();
            } else {
                addToOutput("\nNo compilation to abort!");
            }
        }

        void OnDestroy() {

            if (compilationWaiter != null)
                compilationWaiter.Abort();
            if (generateAutocompleteDictionaryThread != null)
                generateAutocompleteDictionaryThread.Abort();

            Debug.Log("Console threads and processes aborted. Removing log processor and exiting...");

            Application.logMessageReceived -= ProcessLog; //remove Debug.Log listener
        }

        public void p(Toggle t) { //called by toggles, changes their sprites to reflect whether they are checked.
            if (t.isOn) {
                t.GetComponent<Image>().sprite = buttonPressedSprite;
            } else {
                t.GetComponent<Image>().sprite = buttonSprite;
            }
        }

        public void OnEnable() {
            //generates the autocomplete library when the console is opened.
            if (listener.unloadAutocompleteLibraryWhileClosed) {
                autocompletePrepText.transform.parent.gameObject.SetActive(true);
                generateAutocompleteDictionaryThread = new Thread(generateAutocompleteDictionary);
                generateAutocompleteDictionaryThread.Start();
            }
        }

        void OnDisable() {
            //drops the autocomplete library when the console is closed.
            if (listener.unloadAutocompleteLibraryWhileClosed) {
                if (generateAutocompleteDictionaryThread != null)
                    generateAutocompleteDictionaryThread.Abort();
                autocompleteWordsArray = null;
            }
        }

        public static void TypeEnumerate(ref HashSet<string> autocompleteWords, Type[] types) {
            foreach (Type type in types) {
                if (type.IsNotPublic) continue;
                autocompleteWords.Add(type.Name);
                MemberInfo[] members = type.GetMembers();
                foreach (MemberInfo member in members) {
                    switch (member.MemberType) {
                        case MemberTypes.Constructor:
                            continue; //type is already added to dictionary, and name is just (useless) ".ctor"
                        case MemberTypes.Custom: break; //no way to check whether acessible (that I know of)
                        case MemberTypes.Event:
                            EventInfo e = (EventInfo)member;
                            if (e.GetAddMethod().IsPrivate) {
                                if (!e.GetRaiseMethod().IsPrivate) {
                                    if (!e.GetRemoveMethod().IsPrivate) {
                                        if (e.GetOtherMethods(false).Length == 0) continue;
                                    }
                                }
                            }
                            break;
                        case MemberTypes.Field:
                            FieldInfo f = (FieldInfo)member;
                            if (f.IsPrivate) continue;
                            break;
                        case MemberTypes.Method:
                            MethodInfo m = (MethodInfo)member;
                            if (m.IsSpecialName) continue; //the name you have to type will be different than m.Name
                            if (m.IsPrivate) continue;
                            break;
                        case MemberTypes.NestedType: //can't figure out how to check this for publicness. but it might be included in Assembly.GetTypes();
                            break;
                        case MemberTypes.Property:
                            PropertyInfo p = (PropertyInfo)member;
                            if (p.GetAccessors(false).Length == 0) continue;
                            break;
                        case MemberTypes.TypeInfo: //can't figure out how to check this for publicness either. but it too might be included in Assembly.GetTypes();
                            break;
                    }
                    autocompleteWords.Add(member.Name);
                }
            }
        }

        void generateAutocompleteDictionary() {

            title = "...Fetching words...";

            HashSet<string> autocompleteWords = new HashSet<string>();

            if (listener.fullAutocompleteLibrary) {
                //use reflection to get every assembly, type, and member in the domain and add their names to autocompleteWords
                foreach (var assembly in AppDomain.CurrentDomain.GetAssemblies()) {
                    Type[] types = null;
                    try { types = assembly.GetExportedTypes(); } catch (ReflectionTypeLoadException e) { types = e.Types; } //get only acessible types
                    if (types == null)
                        continue;
                    info = assembly.GetName().Name;
                    TypeEnumerate(ref autocompleteWords, types);
                    autocompleteWords.Add(assembly.GetName().Name);
                }
            } else {
                TypeEnumerate(ref autocompleteWords, autocompleteBestTypes);
            }

            info = string.Format("Words in autocomplete: " + autocompleteWords.Count);
            title = "...Querying...";
            IEnumerable<string> query = autocompleteWords.OrderBy(aaaaa => aaaaa);
            title = "...Casting to array...";
            autocompleteWordsArray = query.ToArray();
            title = "Autocomplete ready.";
        }

        public void Opacity(Slider slider) { //changes opcaity of background
            GetComponent<Image>().color = new Color(0, 0, 0, slider.value);
        }

        public void HotkeyExecute(int index) { //for just the auto-type hotkeys
            Hotkey key = hotkeys[index];
            inputField.text = inputField.text.Insert(inputField.caretPosition, key.code);
            inputField.caretPosition += key.cursorOffset;
        }

        public void Autocomplete(int i) { //actually types the suggestion into the input field.
            //if (i >= maxNumAutocompleteSuggestions)
            //    return;
            if (inputField.text == "")
                return;
            string word = autocompleteSuggestions[i];
            if (word == null)
                return;

            for (int g = caret - 1; g >= 0; g--) {
                if (g > inputField.text.Length - 1) {
                    g = inputField.text.Length - 1;
                    if (g < 0)
                        break;
                }
                char c = inputField.text[g];
                if (!char.IsLetterOrDigit(c))
                    break;
                inputField.text = inputField.text.Remove(g, 1);
                caret--;
            }

            if (caret > inputField.text.Length)
                caret = inputField.text.Length;
            else if (caret < 0)
                caret = 0;

            inputField.text = inputField.text.Insert(caret, word);
            caret += word.Length;
            inputField.caretPosition = caret;

            for (int q = 0; q < maxNumAutocompleteSuggestions; q++) {
                autocompleteButtonTexts[q].text = "";
                autocompleteButtonTexts[q].transform.parent.gameObject.SetActive(false);
            }
        }

        public void Clear() { //clears the console.
            outputFieldExpansionText.text = outputFieldRichText = "Console cleared.";
            outputField.text = outputFieldText = "Console cleared.";
            syntaxErrorsLines.Clear();
        }

        void ProcessLog(string logString, string stackTrace, LogType type) {

            //intercepts logs from unity's debug system and prints them out with different colors.

            string color = "#0000ff";
            string color2 = "#000080";
            switch (type) {
                case LogType.Assert:
                    color = "#00ffff";
                    color2 = "#008080";
                    break;
                case LogType.Error:
                    color = "#ff0000";
                    color2 = "#800000";
                    break;
                case LogType.Exception:
                    color = "#ff8000";
                    color2 = "#804000";
                    break;
                case LogType.Log:
                    color = "#00ffff";
                    color2 = "#008080";
                    break;
                case LogType.Warning:
                    color = "#ffff00";
                    color2 = "#808000";
                    break;
            }

            if (showStackTracesToggle.isOn) {
                addToOutput("\n" + logString.Trim() + "\n" + stackTrace.Trim(),
                            "\n<color=" + color + ">" + logString.Trim() + "</color>\n<color=" + color2 + ">" + stackTrace.Trim() + "</color>");
            } else {
                addToOutput("\n" + logString.Trim(),
                                    "\n<color=" + color + ">" + logString.Trim() + "</color>");
            }
        }

        public void toggleShowEnclosingCode() {
            string before = generateEnclosingCode(true);
            string after = generateEnclosingCode(false);
            if (showEnclosingCodeToggle.isOn) {
                inputField.text = before + inputField.text + after;
                inputField.caretPosition += before.Length;
            } else {
                bool b = inputField.text.StartsWith(before);
                bool a = inputField.text.EndsWith(after);
                if (b && a) {
                    inputField.text = inputField.text.Substring(before.Length, inputField.text.Length - (before.Length + after.Length));
                } else {
                    inputField.text = "";
                }
            }
        }

        public void UpdateInputText() { //called whenever the inputfield's text changes.
            UpdateAutocompleteSuggestions();

            //all this stuff turns the lines with syntax errors in them purple.
            if (syntaxErrorsLines.Count > 0) {
                string[] lines = inputField.text.Split(new[] { '\n' }, StringSplitOptions.None);
                for (int i = syntaxErrorsLines.Count - 1; i >= 0; i--) {
                    uint errorLine = syntaxErrorsLines[i];
                    if (errorLine > lines.Length - 1) continue;
                    string line = lines[errorLine];
                    line = "<color=#ff00a0>" + line + "</color>";
                    lines[errorLine] = line;
                }
                inputFieldExpansionText.text = string.Join("\n", lines);
            } else {
                inputFieldExpansionText.text = inputField.text;
            }
        }

        public void UpdateAutocompleteSuggestions() {

            if (!listener.allowAutocomplete)
                return;

            if (generateAutocompleteDictionaryThread == null && autoCompleteToggle.isOn) { //autocomplete is ready
                string f = "";
                for (int j = 0; j < maxNumAutocompleteSuggestions; j++)
                    autocompleteSuggestions[j] = null;
                if (inputField.text.Length > 0) {
                    for (int i = caret - 1; i >= 0; i--) {
                        if (i > inputField.text.Length - 1)
                            i = inputField.text.Length - 1;
                        char c = inputField.text[i];
                        if (!char.IsLetter(c))
                            break;
                        f = c + f;
                    }
                    if (f.Length > 0) {
                        int start = Array.BinarySearch(autocompleteWordsArray, f.ToLower());
                        if (start < 0) start = ~start;
                        int m = 0;
                        for (int i = start; i < autocompleteWordsArray.Length; i++) {

                            string word = autocompleteWordsArray[i];

                            if (!word.ToLower().StartsWith(f.ToLower()))
                                break;
                            if (word.Equals(f))
                                continue;

                            autocompleteSuggestions[m] = word;
                            m++;
                            if (m >= maxNumAutocompleteSuggestions)
                                break;
                        }
                    }
                }

                for (int q = 0; q < maxNumAutocompleteSuggestions; q++) {
                    if (autocompleteSuggestions[q] != null) {

                        switch (q) {
                            case 0:
                                autocompleteButtonTexts[q].text = "<color=#008000>" + autocompleteSuggestions[q].Insert(f.Length, "</color><color=#00ff00>") + "</color>";
                                break;
                            case maxNumAutocompleteSuggestions - 1:
                                autocompleteButtonTexts[q].text = "<color=#ff0080>More not shown...</color>";
                                break;
                            default:
                                autocompleteButtonTexts[q].text = "<color=grey>" + autocompleteSuggestions[q].Insert(f.Length, "</color>");
                                break;
                        }
                        autocompleteButtonTexts[q].transform.parent.gameObject.SetActive(true);
                    } else {
                        autocompleteButtonTexts[q].text = "";
                        autocompleteButtonTexts[q].transform.parent.gameObject.SetActive(false);
                    }
                }
            } else {
                for (int q = 0; q < maxNumAutocompleteSuggestions; q++) {
                    autocompleteButtonTexts[q].text = "";
                    autocompleteButtonTexts[q].transform.parent.gameObject.SetActive(false);
                }
            }
        }

        public void Update() {

            //tooltip fade-in
            Color c = toolTipText.color;
            Color cP = toolTipPanel.color;
            if (toolTipExpansionText.gameObject.activeSelf) {
                c.a += Time.deltaTime * 5;
                cP.a += Time.deltaTime * 5;

                bool k = toolTipExpansionText.supportRichText;
                if (k != c.a > 0)
                    toolTipExpansionText.supportRichText = toolTipText.supportRichText = !k; //rich text can override opacity.
            } else {
                c.a = -2.5f;
                cP.a = -2.5f;
            }
            toolTipText.color = c;
            toolTipPanel.color = cP;

            //displays the status of the autocomplete library generation and helps transition out of it when it ends.
            if (generateAutocompleteDictionaryThread != null) {
                autocompletePrepText.text = title + "\n" + info;
                if (!generateAutocompleteDictionaryThread.IsAlive) {
                    generateAutocompleteDictionaryThread = null;
                    autocompletePrepText.transform.parent.gameObject.SetActive(false);
                    toolTipText.text = "";
                }
            }

            //because inputfields are weird
            if (inputFieldSelected) {
                if (caret != inputField.caretPosition) {
                    caret = inputField.caretPosition;
                    UpdateAutocompleteSuggestions();
                }
            }

            //handles transition from middle to end of command processing
            if (compilationWaiter != null && !compilationWaiter.IsAlive) {
                compilationWaiter = null;
                ProcessCommandEnd();
            }

            //command history r/w
            if (historyIndex == commandHistory.Count - 1) {
                commandHistory[historyIndex] = inputField.text;
            } else {
                if (inputField.text != commandHistory[historyIndex]) {
                    historyIndex = commandHistory.Count - 1;
                }
            }

            //makes the tooltip go between the mouse and the screen edge
            Vector2 a = Camera.main.ScreenToViewportPoint(Input.mousePosition);
            a.x = Mathf.Round(a.x);
            if (a.y < 0.5)
                a.y = -1;
            else
                a.y = 2;
            toolTipExpansionText.rectTransform.pivot = a;

            //controls height of console element to fit children for proper scrolling
            Vector3[] corners = new Vector3[4];
            top.GetWorldCorners(corners);
            float topHeight = corners[2].y;
            bottom.GetWorldCorners(corners);
            float bottomHeight = corners[0].y;
            Vector2 sd = console.sizeDelta;
            sd.y = 20 + topHeight - bottomHeight; //20 is a margin
            console.sizeDelta = sd;

            //autocomplete sugegstions fill to top of screen
            autocompleteButtonPanel.GetWorldCorners(corners);
            bottomHeight = corners[0].y;
            sd = autocompleteButtonPanel.sizeDelta;
            sd.y = Screen.height - bottomHeight;
            autocompleteButtonPanel.sizeDelta = sd;

            //selected object indicator
            string wantedText = "";
            if (listener.selectedObject != null)
                wantedText = "Use <b><color=#00ff00>so</color></b> as a variable in your commands to reference <b><color=#00ff00>" + listener.selectedObject + "</color></b>. For example, <i>Debug.Log(so.transform.position);</i>.";
            else
                wantedText = "Right click an object to select it.";
            if (selectedObjectText.text != wantedText)
                selectedObjectText.text = wantedText;

            //placeholder text
            string wantedPlaceholderText = languageToggle.isOn ? "Enter a command here. (C# Commands should be in the form of raw C# code.)" : "Enter a command here. (UnityScript commands should be in the form of raw UnityScript code.)";
            if (((Text)inputField.placeholder).text != wantedPlaceholderText)
                ((Text)inputField.placeholder).text = wantedPlaceholderText;

            //object selector
            if (Input.GetMouseButtonDown(1) && !inputField.isFocused) {
                RaycastHit h;
                if (Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out h)) {
                    listener.selectedObject = h.collider.gameObject;
                } else {
                    listener.selectedObject = null;
                }
            }

            //trigegr command processing
            if (Input.GetKeyDown(KeyCode.Return) && enterCompilesToggle.isOn) {
                ProcessCommandBeginning();
            }
            if (Input.GetKey(KeyCode.LeftControl) || Input.GetKey(KeyCode.RightControl)) {
                if (Input.GetKeyDown(KeyCode.LeftShift) || Input.GetKeyDown(KeyCode.RightShift)) {
                    ProcessCommandBeginning();
                }
            }

            if (inputField.interactable) { //if not compiling
                                           //auto-type hotkeys
                if (Input.GetKey(KeyCode.LeftControl) || Input.GetKey(KeyCode.RightControl)) {
                    if (Input.GetKey(KeyCode.LeftAlt) || Input.GetKey(KeyCode.RightAlt) || Input.GetKey(KeyCode.AltGr)) {
                        foreach (Hotkey key in hotkeys) {
                            if (Input.GetKeyDown(key.key)) {
                                inputField.text = inputField.text.Insert(inputField.caretPosition, key.code);
                                inputField.caretPosition += key.cursorOffset;
                            }
                        }
                    }
                }
                //command history scrolling
                if (Input.GetKey(KeyCode.LeftControl) || Input.GetKey(KeyCode.RightControl)) {
                    if (Input.GetKeyDown(KeyCode.UpArrow)) {
                        scrollCommandHistory(true);
                    }
                    if (Input.GetKeyDown(KeyCode.DownArrow)) {
                        scrollCommandHistory(false);
                    }
                }
                //autocomplete
                if (!Input.GetKey(KeyCode.LeftControl) && !Input.GetKey(KeyCode.RightControl)) {
                    if (Input.GetKey(KeyCode.LeftAlt) || Input.GetKey(KeyCode.RightAlt) || Input.GetKey(KeyCode.AltGr)) {
                        Autocomplete(0);
                    }
                }
            }
        }

        public void scrollCommandHistory(bool direction) { //true is up
            if (direction && historyIndex > 0) {
                historyIndex--;
                inputField.text = commandHistory[historyIndex];
            } else if (!direction && historyIndex < commandHistory.Count - 1) {
                historyIndex++;
                inputField.text = commandHistory[historyIndex];
            }
        }

        public void LateUpdate() {
            //makes the tooltip follow thw mouse cursor
            toolTipExpansionText.transform.position = Input.mousePosition;
            toolTipExpansionText.text = toolTipText.text;
            toolTipExpansionText.gameObject.SetActive(toolTipText.text != "");
        }

        public string generateEnclosingCode(bool before) {//this code is placed before and after the user-inputted command to appease the compiler gods.
            if (languageToggle.isOn) {
                if (before) {
                    return
                    "using UnityEngine;" + '\n' +
                    "using System;" + '\n' +
                    "using CharlesOlinerCommandConsole;" + '\n' +
                    "public class ConsoleCommand" + numGenerated.ToString("00000000000000000000") + ": ConsoleCommand{" + '\n' +
                        "\tpublic static object Command() {" + '\n' +
                            "\t\t";
                } else {
                    return
                                                 '\n' +
                            "\t\treturn \"\";" + '\n' +
                        "\t}" + '\n' +
                    "}";
                }
            } else {
                if (before) {
                    return
                    "var so: GameObject = EvaluatorHelper.selectedObject;" + '\n';
                } else {
                    return "";
                }
            }
        }
        //if the enclosing code changes, this value too must be changed
        int lineOffset { get { return languageToggle.isOn ? 5 : 1; } } //number of lines in the before part of the enclosing code

        public void setSelectedObject(GameObject so) {
            listener.selectedObject = so;
        }
        public void setSelectedObjectNull() {
            listener.selectedObject = null;
        }

        public void ProcessCommandBeginning() {

            if (!inputField.interactable) //if already compiling, don't compile more
                return;

            //Unity is always \n, so get rid of every \r
            inputField.text = inputField.text.Trim();
            inputField.text = inputField.text.Replace("\r", "");
            if (inputField.text == "")
                return;

            //command history stuff
            commandHistory[commandHistory.Count - 1] = inputField.text;
            commandHistory.Add("");
            historyIndex = commandHistory.Count - 1;

            if (!languageToggle.isOn) {
                addToOutput("\n" + inputField.text, "\n<color=#00a000>" + inputField.text + "</color>");
                if (listener.selectedObject != null)
                    gameObject.SendMessage("setSelected", listener.selectedObject);
                else
                    gameObject.SendMessage("setSelectedNull");
                string code = showEnclosingCodeToggle.isOn ? inputField.text : generateEnclosingCode(true) + inputField.text + generateEnclosingCode(false);
                gameObject.SendMessage("evaluate", code);
                return;
            }

            //make buttons that would otherwise break the system non-interactible.
            inputField.interactable = false;
            foreach (Button b in supressDuringCompilationButtons) {
                b.interactable = false;
            }
            showEnclosingCodeToggle.interactable = false;
            showEnclosingCodeToggle.GetComponent<Image>().sprite = buttonDisabledSprite;
            languageToggle.interactable = false;

            //start next part of compilation
            compilationWaiter = new Thread(ProcessCommandMiddle);
            compilationWaiter.Start();
        }

        void ProcessCommandMiddleUnityScript(object retValue) {

            if (showEnclosingCodeToggle.isOn)
                inputField.text = generateEnclosingCode(true) + generateEnclosingCode(false);
            else
                inputField.text = "";

            if (retValue != null) {
                addToOutput("\n" + retValue.ToString(), "\n<color=#00ff00>" + retValue.ToString() + "</color>");
            } else {
                addToOutput("\nnull", "\n<color=#00ff00>null</color>");
            }
        }
        void ProcessCommandMiddleUnityScriptNull() {
            ProcessCommandMiddleUnityScript(null);
        }

        void ProcessCommandMiddle() {

            string effectiveDllInputPath = "commandLibrary" + numGenerated.ToString("00000000000000000000") + ".dll";

            string code = inputField.text;

            if (!showEnclosingCodeToggle.isOn) {
                code = generateEnclosingCode(true) + code + generateEnclosingCode(false);
            }

            var syntaxErrors = CSharpCompiler.Compile(code, effectiveDllInputPath, listener.compilerVersion);
            standardOutput = "";
            syntaxErrorsLines.Clear();
            foreach (CompilerError syntaxError in syntaxErrors) {
                int line = syntaxError.Line;
                line -= 1;
                if (!showEnclosingCodeToggle.isOn) {
                    line -= lineOffset;
                }
                if (line >= 0)
                    syntaxErrorsLines.Add((uint)line);

                standardOutput += "\nSyntax " + (syntaxError.IsWarning ? "warning " : "error ") + syntaxError.ErrorNumber + " on line " + line + ": " + syntaxError.ErrorText;
            }
        }

        void ProcessCommandEnd() {

            string effectiveDllInputPath = "commandLibrary" + numGenerated.ToString("00000000000000000000") + ".dll";

            addToOutput("\n" + inputField.text, "\n<color=#00a000>" + inputField.text + "</color>");

            if (!File.Exists(effectiveDllInputPath)) {
                //output syntax errors
                if (standardOutput != null) {
                    standardOutput = standardOutput.Trim();
                    addToOutput("\n" + standardOutput, "\n<color=#ff00a0>" + standardOutput + "</color>");
                }
                numGenerated++;
            } else {
                //load back compiled code
                var assembly = Assembly.LoadFile(effectiveDllInputPath);
                Type[] types = assembly.GetTypes();
                foreach (Type type in types) {
                    MethodInfo[] methods = type.GetMethods();
                    foreach (MethodInfo method in methods) {
                        if (method.IsStatic && method.Name == "Command") {
                            object o = null;
                            try {
                                o = method.Invoke(null, null);
                            } catch (Exception e) {
                                Debug.LogException(e);
                            }
                            if (o != null) {
                                if (o.ToString() != "") {
                                    addToOutput("\n" + o.ToString(), "\n<color=#00ff00>" + o.ToString() + "</color>");
                                }
                            } else {
                                addToOutput("\nnull", "\n<color=#00ff00>null</color>");
                            }
                        }
                    }
                }
                numGenerated++;
                if (showEnclosingCodeToggle.isOn)
                    inputField.text = generateEnclosingCode(true) + generateEnclosingCode(false);
                else
                    inputField.text = "";
            }

            //re-enable elements disabled earlier.
            inputField.interactable = true;
            foreach (Button b in supressDuringCompilationButtons) {
                b.interactable = true;
            }
            showEnclosingCodeToggle.interactable = true;
            languageToggle.interactable = true;
            p(showEnclosingCodeToggle);

            UpdateInputText();
        }

        public void addToOutput(string msg, string richMsg = null) { //logs a message to the outputfield.

            //two strings are required because inputfields don't support rich text.
            //this system layers a rich textbox over an invisible inputfield textbox.
            //we only need the inputfield textbox for copy-pasting.

            if (richMsg == null)
                richMsg = msg;

            outputFieldText += msg;
            outputFieldRichText += richMsg;

            outputField.text = outputFieldText;
            outputFieldExpansionText.text = outputFieldRichText;
        }
    }
}